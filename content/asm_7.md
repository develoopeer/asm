
Это седьмая часть цикла статей "Say hello to x86_64 Assembly", и в ней мы рассмотрим, как мы можем использовать язык C вместе с ассемблером.

На самом деле у нас есть 3 способа использовать их вместе:

* Вызов процедур ассемблера из кода C
* Вызов процедур C из кода ассемблера
* Использование встроенного ассемблера в коде C

Давайте напишем 3 простые программы Hello world, которые покажут нам, как использовать ассемблер и C вместе.

## Вызов кода ассемблера из кода C

Для начала давайте напишем простую программу на языке C, например:

```C
#include <string.h>

int main() {
	char* str = "Hello World\n";
	int len = strlen(str);
	printHelloWorld(str, len);
	return 0;
}
```

Здесь мы видим код C, который определяет две переменные: нашу строку Hello world, которую мы запишем в `stdout`, и длину этой строки. Затем мы вызываем функцию ассемблера `printHelloWorld` с этими 2 переменными в качестве параметров. Поскольку мы используем x86_64 Linux, мы должны знать правила вызова x86_64 linux, для того чтобы знать, как написать функцию `printHelloWorld`, как получить входящие параметры и т. д. Когда мы вызываем функцию, первые шесть параметров проходят через регистры общего назначения `rdi`, `rsi`, `rdx`, `rcx`, `r8` и `r9`, все остальные через стек. Таким образом, мы можем получить первый и второй параметры из регистров `rdi` и `rsi` и вызвать системный вызов `write`, а затем вернуться из функции с помощью инструкции `ret`:

```assembly
global printHelloWorld

section .text
printHelloWorld:
		;; 1 arg
		mov r10, rdi
		;; 2 arg
		mov r11, rsi
		;; call write syscall
		mov rax, 1
		mov rdi, 1
		mov rsi, r10
		mov rdx, r11
		syscall
		ret
```

Теперь мы можем скомпилировать и собрать исполняемый файл с помощью:

```
build:
	nasm -f elf64 -o casm.o casm.asm
	gcc casm.o casm.c -o casm
```

## Встроенный ассемблер

Следующий метод заключается в написании ассемблерного кода непосредственно в коде C. Для этого существует специальный синтаксис. Он имеет общий вид:

```
asm [volatile] ("assembly code" : output operand : input operand : clobbers);
```

Как мы можем прочитать в документации gcc, ключевое слово volatile означает:

```
Типичное использование расширенных выражений asm — манипулирование входными значениями для получения выходных значений. Однако ваши операторы asm могут также создавать побочные эффекты. Если это так, вам может потребоваться использовать квалификатор volatile для отключения определенных оптимизаций
```

Каждый операнд описывается строкой ограничений, за которой в скобках следует выражение C. Существует ряд ограничений:

* `r` - Сохраненное значение переменной в регистре общего назначения
* `g` - Разрешен любой регистр, память или непосредственный целочисленный операнд, за исключением регистров, которые не являются общими регистрами.
* `f` - Регистр с плавающей точкой
* `m` - Разрешен операнд памяти с любым типом адреса, который машина поддерживает в принципе.
* и т. д.

Итак наше приложение будет выглядеть следующим образом:

```C
#include <string.h>

int main() {
	char* str = "Hello World\n";
	long len = strlen(str);
	int ret = 0;

	__asm__("movq $1, %%rax \n\t"
		"movq $1, %%rdi \n\t"
		"movq %1, %%rsi \n\t"
		"movl %2, %%edx \n\t"
		"syscall"
		: "=g"(ret)
		: "g"(str), "g" (len));

	return 0;
}
```

Здесь мы видим те же 2 переменные, что и в предыдущем примере, и определение встроенного ассемблера. Прежде всего мы помещаем 1 в регистры `rax` и `rdi` (запись номера системного вызова и `stdout`), как мы делали это в нашем простом "Hello world". Затем мы выполняем похожую операцию с регистрами `rsi` и `rdi`, но первый операнд начинается с символа % вместо $. Это означает, что `str` — это выходной операнд, на который ссылается %1, а `len` — второй выходной операнд, на который ссылается %2, поэтому мы помещаем значения `str` и `len` в `rsi` и `rdi` с нотацией `%n`, где n — номер выходного операнда. Также есть префикс к имени регистра добавляется префикс `%%`.

```
    Это помогает GCC различать операнды и регистры. Операнды имеют один префикс %
```


Теперь мы можем скомпилировать и собрать исполняемый файл с помощью:
```
build:
	gcc casm.c -o casm
```

## Вызов кода C из ассемблера

И последний метод — вызвать функцию C из ассемблерного кода. Например, у нас есть следующий простой код C с одной функцией, которая просто печатает Hello world:

```C
#include <stdio.h>

extern int print();

int print() {
	printf("Hello World\n");
	return 0;
}
```

Теперь мы можем определить эту функцию как `extern` в нашем ассемблерном коде и вызвать ее с помощью инструкции call, как мы делали это много раз в предыдущих постах:

```asssembly
global _start

extern print

section .text

_start:
		call print

		mov rax, 60
		mov rdi, 0
		syscall
```

Компилируем и собираем исполняемый файл с помощью:

```
build:
	gcc  -c casm.c -o c.o
	nasm -f elf64 casm.asm -o casm.o
	ld   -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc casm.o c.o -o casm
```

и теперь мы можем запустить наш третий и последний на сегодня "Hello World".
