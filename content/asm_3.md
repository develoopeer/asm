
Как мы уже помним стек — это специальная область в памяти, которая работает по принципу LIFO (Last Input, First Output).

У нас есть 16 регистров общего назначения для временного хранения данных. Это RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP и R8-R15. Этого слишком мало для серьезных приложений. Поэтому мы можем хранить данные в стеке. Еще одно использование стека следующее: когда мы вызываем функцию, возвращаем адрес, скопированный в стек. После завершения выполнения функции адрес копируется в счетчик команд (RIP), и приложение продолжает выполняться со следующего места после функции.

Например:

```assembly
global _start

section .text

_start:
		mov rax, 1
		call incRax
		cmp rax, 2
		jne exit
		;;
		;; Do something
		;;

incRax:
		inc rax
		ret
```

Здесь мы видим, что после запуска приложения регистр `rax` равен 1. Затем мы вызываем функцию `incRax`, которая увеличивает значение `rax` до 1, и теперь значение `rax` должно быть равно 2. После этого выполнение продолжается с 8 строки, где мы сравниваем значение `rax` с 2. Также, как мы можем прочитать в [System V AMD64 ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf), первые шесть аргументов функции передаются в регистрах. Это:

* `rdi` - первый аргумент
* `rsi` - второй аргумент
* `rdx` - третий аргумент
* `rcx` - четвертый аргумент
* `r8`   - пятый аргумент
* `r9`   - шестой аргумент

Последующие аргументы будут переданы через стек. Так что если у нас есть такая функция:

```C
int foo(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
    return (a1 + a2 - a3 - a4 + a5 - a6) * a7;
}
```

Первые шесть аргументов будут переданы через регистры, а седьмой аргумент будет передан через стек.

## Указатель стека

Как я уже писал, у нас есть 16 регистров общего назначения, и есть два интересных регистра - RSP и RBP. RBP - это регистр указателя базы. Он указывает на базу текущего кадра стека. RSP - это указатель стека, который указывает на вершину текущего кадра стека.

Так же у нас есть две инструкции для работы со стеком:

* `push argument` - увеличивает указатель стека (RSP) и сохраняет аргумент в месте, указанном указателем стека
* `pop argument` - копирует данные в аргумент из места, указанного указателем стека

Давайте рассмотрим один простой пример:

```assembly
global _start

section .text

_start:
		mov rax, 1
		mov rdx, 2
		push rax
		push rdx

		mov rax, [rsp + 8]

		;;
		;; Do something
		;;
```

Здесь мы видим, как происходит помещение единицы в регистр `rax` и двойки в регистр `rdx`. После этого мы помещаем в стек значения этих регистров. Так как тек работает по принципу LIFO (Last In First Out), после выполнения он будет иметь следующую структуру:

![stack diagram](/content/assets/stack-diagram.png)

Затем копируем значение из стека, адрес вершины которого указан в регистре `rsp`, прибавляем к нему 8 и копируем данные по этому адресу в `rax`. После этого значение `rax` будет равно 1.

## Пример

Давайте рассмотрим один пример. Мы напишем простую программу, которая получит два аргумента командной строки. Посчитает сумму этих аргументов и выведет результат.

```assembly
section .data
		SYS_WRITE equ 1
		STD_IN    equ 1
		SYS_EXIT  equ 60
		EXIT_CODE equ 0

		NEW_LINE   db 0xa
		WRONG_ARGC db "Must be two command line argument", 0xa
```

Прежде всего, мы определяем раздел `.data` с некоторыми значениями. Здесь у нас есть четыре константы для системных вызовов Linux, для sys_write, sys_exit и т. д. А также у нас есть две строки: первая — просто символ новой строки, а вторая — сообщение об ошибке.

Теперь же, посмотрим на раздел `.text`, который состоит из кода нашей программы:

```assembly
section .text
        global _start

_start:
		pop rcx
		cmp rcx, 3
		jne argcError

		add rsp, 8
		pop rsi
		call str_to_int

		mov r10, rax
		pop rsi
		call str_to_int
		mov r11, rax

		add r10, r11
```

Давайте попробуем понять, что здесь происходит: После метки `_start` первая инструкция получает первое значение из стека и помещает его в регистр `rcx`. Если мы запустим приложение с аргументами командной строки, то все они будут в стеке после запуска в следующем порядке:

```
    [rsp] - вершина стека будет указывать на количество переданных аргументов
    [rsp + 8] - первый агрумент argv[0]
    [rsp + 16] - второй аргумент argv[1]
    и так далее...
```

Итак, мы получаем количество аргументов командной строки и помещаем его в `rcx`. После этого мы сравниваем `rcx` со значением 3, и если они не равны, мы переходим к метке `argcError`, которая просто выводит сообщение об ошибке:

```assembly
argcError:
    ;; sys_write syscall
    mov     rax, 1
    ;; file descritor, standard output
	mov     rdi, 1
    ;; message address
    mov     rsi, WRONG_ARGC
    ;; length of message
    mov     rdx, 34
    ;; call write syscall
    syscall
    ;; exit from program
	jmp exit
```

Почему мы сравниваем количество аргументов с тройкой, когда у нас два аргумента?Все просто. Первый аргумент — это имя программы, а все после него — это аргументы командной строки, которые мы ей передали. Хорошо, если мы передали два аргумента командной строки, то переходим на строку 10. Здесь мы сдвигаем `rsp` на 8 и тем самым пропускаем первый аргумент — имя программы. Теперь `rsp` указывает на первый аргумент командной строки, который мы передали. Мы получаем его с помощью команды `pop`, помещаем в регистр `rsi` и вызываем функцию для преобразования его в целое число. Далее мы читаем о реализации `str_to_int`. После того, как наша функция завершает работу, у нас есть целочисленное значение в регистре `rax`, и мы сохраняем его в регистре `r10`. После этого мы делаем ту же операцию, но с `r11`. В итоге у нас есть два целочисленных значения в регистрах `r10` и `r11`, теперь мы можем получить их сумму с помощью инструкции `add`. Дальше мы должны преобразовать результат в строку и вывести ее на экран. Давайте посмотрим, как это сделать:

```assembly
mov rax, r10
;; number counter
xor r12, r12
;; convert to string
jmp int_to_str
```

Здесь мы помещаем сумму аргументов командной строки в регистр `rax`, устанавливаем `r12` в ноль и переходим к `int_to_str`. Хорошо, у нас есть каркас программы. Мы уже знаем, как печатать строку, и у нас есть что напечатать. Давайте же посмотрим на реализацию `str_to_int` и `int_to_str`.

```assembly
str_to_int:
        xor rax, rax
        mov rcx,  10
next:
	    cmp [rsi], byte 0
	    je return_str
	    mov bl, [rsi]
            sub bl, 48
	    mul rcx
	    add rax, rbx
	    inc rsi
	    jmp next

return_str:
	    ret
```

В начале `str_to_int` мы обнуляем регистр `rax`, и устанавливаем значение 10 в `rcx`. Затем переходим к следующей метке. Как вы можете видеть в примере выше (первая строка перед первым вызовом `str_to_int`), мы помещаем `argv[1]` в `rsi` из стека. Теперь мы сравниваем первый байт `rsi` с 0, потому что каждая строка заканчивается символом NULL, и если это так, мы возвращаемся. Если это не так, мы копируем его значение в однобайтовый регистр bl и вычитаем из него 48. Почему 48? Все числа от 0 до 9 имеют коды от 48 до 57 в таблице asci. Так что если мы вычитаем из символа числа 48 (например, из 57), мы получаем число. Затем мы умножаем `rax` на `rcx` (который имеет значение - 10). После этого мы увеличиваем `rsi` для получения следующего байта и снова выполняем цикл. Алгоритм прост. Например, если `rsi` указывает на последовательность «5», «7», «6», «\000», то будут выполнены следующие шаги:

```
    rax = 0
    get first byte - 5 and put it to rbx
    rax * 10 --> rax = 0 * 10
    rax = rax + rbx = 0 + 5
    Get second byte - 7 and put it to rbx
    rax * 10 --> rax = 5 * 10 = 50
    rax = rax + rbx = 50 + 7 = 57
    and loop it while rsi is not \000
```

После выполнения `str_to_int` у нас будет некоторое число в `rax`. Теперь давайте посмотрим на `int_to_str`:

```assembly
int_to_str:
		mov rdx, 0
		mov rbx, 10
		div rbx
		add rdx, 48
		add rdx, 0x0
		push rdx
		inc r12
		cmp rax, 0x0
		jne int_to_str
		jmp print
```

Здесь мы помещаем 0 в `rdx` и 10 в `rbx`. Затем мы выполняем инструкцию `div rbx`. Если мы посмотрим на код выше перед вызовом `str_to_int`. Мы увидим, что `rax` содержит целое число - сумму двух аргументов командной строки. С помощью этой инструкции мы делим значение `rax` на значение `rbx` и получаем остаток в `rdx` и целую часть в `rax`. Затем мы прибавляем к `rdx` 48 и 0x0. После прибавления 48 мы получим `asci`-символ этого числа, и все строки должны заканчиваться на 0x0. После этого мы сохраняем символ в стеке, увеличиваем `r12` (он равен 0 на первой итерации, мы устанавливаем его в 0 в _start) и сравниваем `rax` с 0, если он равен 0, то мы закончили преобразование целого числа в строку. Пошаговый алгоритм следующий: Например, у нас есть число 23

```
    123 / 10. rax = 12; rdx = 3
    rdx + 48 = "3"
    push "3" to stack
    compare rax with 0 if no go again
    12 / 10. rax = 1; rdx = 2
    rdx + 48 = "2"
    push "2" to stack
    compare rax with 0, if yes we can finish function execution and we will have "2" "3" ... in stack
```

Мы реализовали две полезные функции `int_to_str` и `str_to_int` для преобразования целого числа в строку и наоборот. Теперь у нас есть сумма двух целых чисел, которая была преобразована в строку и сохранена в стеке. Мы можем вывести результат:

```assembly
print:
	;;;; calculate number length
	mov rax, 1
	mul r12
	mov r12, 8
	mul r12
	mov rdx, rax

	;;;; print sum
	mov rax, SYS_WRITE
	mov rdi, STD_IN
	mov rsi, rsp
	;; call sys_write
	syscall

    jmp exit
```

Мы уже знаем, как вывести строку с помощью системного вызова `sys_write`, но вот одна интересная вещь. Мы должны вычислить длину строки. Если вы посмотрите на `int_to_str`, вы увидите, что мы увеличиваем регистр `r12` на каждой итерации, поэтому он содержит количество цифр в нашем числе. Мы должны умножить его на 8 (потому что мы помещаем каждый символ в стек), и это будет длина нашей строки, которую нужно вывести. После этого мы, как и каждый раз, устанавливаем единицу в `rax` (номер sys_write), 1 в `rdi` (stdin), длину строки в `rdx` и указатель на вершину стека в `rsi` (начало строки). И завершаем нашу программу:

```assembly
exit:
	mov rax, SYS_EXIT
	exit code
	mov rdi, EXIT_CODE
	syscall
```

Это все.
