
Некоторое время назад я начал написание серии постов в блоге о программировании на ассемблере для архитектуры x86_64. К сожалению, в прошлый раз я был занят, и новых постов не было, поэтому сегодня я продолжаю писать посты об ассемблере и постараюсь делать это каждую неделю.

Сегодня мы рассмотрим строки и некоторые операции со строками. Мы по-прежнему используем ассемблер NASM и Linux x86_64.

## Переворачивание строки

Конечно, когда мы говорим о языке программирования ассемблер, мы не можем говорить о строковом типе данных, ведь на самом деле мы имеем дело с массивом байтов. Давайте попробуем написать простой пример, в котором определим строковые данные, попробуем их перевернуть и записать результат в `stdout`. Эта задача кажется довольно простой и даже тривиальной, при изучение нового языка программирования. Давайте же рассмотрим ее реализацию.

Прежде всего, мы определим инициализированные данные в сегменте `data`:

```assembly
section .data
		SYS_WRITE equ 1
		STD_OUT   equ 1
		SYS_EXIT  equ 60
		EXIT_CODE equ 0

		NEW_LINE db 0xa
		INPUT db "Hello world!"
```

Взглянем на следующие 4 константы:

* `SYS_WRITE` - номер системного вызова `sys_write`
* `STD_OUT`     - номер файлового дескриптора `stdout`
* `SYS_EXIT`   - номер системного вызова `exit`
* `EXIT_CODE` - код завершения вызова `exit`

Список системных вызовов вы можете найти - [здесь](https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl). 
Также в секции `data` определены:

* `NEW_LINE` - символ новой строки `\n`
* `INPUT` - наша строка, который нужно перевернуть

Далее, разделе `bss`, мы определяем  переменную для нашего буфера, куда мы поместим перевернутую строку:

```assembly
section .bss
		OUTPUT resb 12
```

Хорошо, у нас есть некоторые данные и буфер для вывода результата, теперь мы можем определить текстовую секцию для кода. Давайте начнем с основной процедуры _start:

```assembly
_start:
		mov rsi, INPUT
		xor rcx, rcx
		cld
		mov rdi, $ + 15
		call calculateStrLength
		xor rax, rax
		xor rdi, rdi
		jmp reverseStr
```

Сначала мы помещаем адрес INPUT в регистр `si` в строке 2, как мы делали для записи в `stdout` и записываем нули в регистр `rcx`, это будет счетчик для вычисления длины нашей строки. В строке 4 мы видим оператор `cld`. Он сбрасывает флаг `df` в ноль. Он нам нужен, потому что когда мы будем вычислять длину строки, мы будем проходить по символам этой строки, и если флаг `df` будет равен 0, мы будем обрабатывать символы строки слева направо. Далее мы вызываем функцию `calculateStrLength`. Я пропустил строку 5 с инструкцией `mov rdi, $ + 15`, но расскажу о ней немного позже. А теперь давайте рассмотрим реализацию `calculateStrLength`:

```assembly
calculateStrLength:
		;; check is it end of string
		cmp byte [rsi], 0
		;; if yes exit from function
		je exitFromRoutine
		;; load byte from rsi to al and inc rsi
		lodsb
		;; push symbol to stack
		push rax
		;; increase counter
		inc rcx
		;; loop again
		jmp calculateStrLength
```

Как вы можете понять из названия, эта функция просто вычисляет длину ВХОДНОЙ строки и сохраняет результат в регистре `rcx`. Сначала мы проверяем, что регистр `rsi` не указывает на ноль, если это так, то это конец строки, и мы можем выйти из функции. Далее идет инструкция `lodsb`. Она проста, она просто помещает 1 байт в регистр `al` (младшая часть 16-битного `ax`) и изменяет указатель `rsi`. Когда мы выполнили инструкцию `cld, lodsb` каждый раз будет перемещать `rsi` на один байт слева направо, поэтому мы будем перемещаться по символам строки. 
После этого мы помещаем значение `rax` в стек, теперь оно содержит символ из нашей строки (`lodsb` помещает байт из `si` в `al`, `al` — это младшие 8 бит `rax`). Зачем мы помещаем символ в стек? Вы должны помнить, как работает стек, он работает по принципу LIFO (последний вошел, первый вышел). Мы возьмем первый символ из `si`, поместим его в стек, затем второй и так далее. Таким образом, последний символ строки будет наверху стека. Затем мы просто заберем символ за символом из стека и запишем в буфер OUTPUT. После этого мы увеличиваем наш счетчик `rcx` и снова возвращаемся к началу процедуры.

Хорошо, мы поместили все символы из строки в стек, теперь мы можем перейти к выходу из процедуры и вернуться к `_start`. Как это сделать? У нас есть инструкция `ret` для этого. Но если код будет выглядеть вот так:

```assembly
exitFromRoutine:
		;; return to _start
		ret
```

то ничего не заработает. Вы спросите почему? Объяснение довольно необычно. Помните, мы вызвали `calculateStrLength` в `_start`. Что происходит, когда мы вызываем функцию? Сначала параметры функции помещаются в стек справа налево. После этого адрес возврата помещается в стек. Таким образом, функция будет знать, куда вернуться после завершения выполнения. Но посмотрите на `calculateStrLength`, мы помещаем символы из нашей строки в стек, и теперь нет адреса возврата вершины стека, и функция не знает, куда вернуться. Теперь мы должны взглянуть на странную инструкцию перед вызовом:

```assembly
    mov rdi, $ + 15
```

Для начала

* `$` - возвращает позицию в памяти строки, где определен $
* `$$` - возвращает позицию в памяти текущего раздела

Итак, у нас есть позиция `mov rdi, $ + 15`, непонятно только почему мы добавляем 15? Смотрите, нам нужно знать позицию следующей строки после `calculateStrLength`. Давайте откроем наш файл с помощью утилиты `objdump`:

```assembly
objdump -D reverse

reverse:     file format elf64-x86-64

Disassembly of section .text:

00000000004000b0 <_start>:
  4000b0:	48 be 41 01 60 00 00 	movabs $0x600141,%rsi
  4000b7:	00 00 00
  4000ba:	48 31 c9             	xor    %rcx,%rcx
  4000bd:	fc                   	cld
  4000be:	48 bf cd 00 40 00 00 	movabs $0x4000cd,%rdi
  4000c5:	00 00 00
  4000c8:	e8 08 00 00 00       	callq  4000d5 <calculateStrLength>
  4000cd:	48 31 c0             	xor    %rax,%rax
  4000d0:	48 31 ff             	xor    %rdi,%rdi
  4000d3:	eb 0e                	jmp    4000e3 <reverseStr>
```

Здесь мы видим, что строка 12 (наш `mov rdi, $ + 15`) занимает 10 байт, а вызов функции в строке 16 - 5 байт, так что он занимает 15 байт. Вот почему наш адрес возврата будет `mov rdi, $ + 15`. Теперь мы можем поместить адрес возврата из `rdi` в стек и вернуться из функции:

```assembly
exitFromRoutine:
		;; push return addres to stack again
		push rdi
		;; return to _start
		ret
```

Теперь возвращаемся к `_start`. После вызова `calculateStrLength` записываем нули в регистры `rax` и `rdi` и переходим на метку `reverseStr`. Реализация будет выглядить вот так:

```assembly
reverseStr:
		cmp rcx, 0
		je printResult
		pop rax
		mov [OUTPUT + rdi], rax
		dec rcx
		inc rdi
		jmp reverseStr
```

Здесь мы проверяем наш счетчик, равный остаточной длине строки, и если он равен нулю, мы записываем все символы в буфер и можем его распечатать. После проверки счетчика мы извлекаем из стека в регистр `rax` первый символ и записываем его в буфер OUTPUT. Мы добавляем `rdi`, потому что в противном случае мы запишем символ в первый байт буфера. После этого мы увеличиваем `rdi` для перемещения дальше по буферу OUTPUT, уменьшаем счетчик длины и переходим к началу метки.

После выполнения `reverseStr` мы перевернули строку в буфере OUTPUT будет лежать перевернутая строка и можем записать результат в stdout:

```assembly
printResult:
		mov rdx, rdi
		mov rax, 1
		mov rdi, 1
		mov rsi, OUTPUT
                syscall
		jmp printNewLine

printNewLine:
		mov rax, SYS_WRITE
		mov rdi, STD_OUT
		mov rsi, NEW_LINE
		mov rdx, 1
		syscall
		jmp exit
```

и выйти из нашей программы:

```assembly
exit:
		mov rax, SYS_EXIT
		mov rdi, EXIT_CODE
		syscall
```

Вот и все, теперь мы можем скомпилировать нашу программу с помощью:

```assembly
all:
	nasm -g -f elf64 -o reverse.o reverse.asm
	ld -o reverse reverse.o

clean:
	rm reverse reverse.o
```

и запустить ее:

![result](/content/assets/result_asm_4.png)

## Операции со строками

Конечно, существует множество других инструкций для манипуляций со строками/байтами:

* `REP` - повторять до тех пор пока rcx не ноль
* `MOVSB` - скопировать строку байтов (MOVSW, MOVSD and etc..)
* `CMPSB` - сравнение последовательности байтов
* `SCASB` - просмотр строки из байтов
* `STOSB` - запись байта в строку
